// ============================================
// PRISMA SCHEMA - App Analyzer (Hybrid Pricing)
// ============================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // O mysql/sqlite según tu caso
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================


// Actualizado a tus nuevos planes
enum PlanType {
  FREE
  PRO_INDIE
  POWER_BUSINESS
}

enum PlanStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  PAUSED
}

enum SubscriptionProvider {
  LEMONSQUEEZY
}

enum CreditTransactionType {
  DEDUCTION       // Gasto de IA
  REFUND          // Error en GPT
  PURCHASE        // Pack extra
  SUBSCRIPTION    // Recarga mensual
  BONUS           // Regalo manual
  ADMIN_ADJUSTMENT
}

enum PurchaseType {
  SUBSCRIPTION
  PACK_ONE_TIME   // Para packs de créditos extra
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELED
}

enum Platform {
  ANDROID
  IOS
  WEB
}

enum FeaturePriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ChatRole {
  USER
  ASSISTANT
  SYSTEM
}

enum PlanInterval {
  MONTHLY
  YEARLY
}

enum QuestStatus {
  ACTIVE
  COMPLETED
  CLAIMED
  EXPIRED
}

// ============================================
// BETTER AUTH MODELS (User & Session)
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  
  // Settings
  theme          String?   @default("system")
  language       String?   @default("en")
  
  // Access Control
  banned       Boolean   @default(false)
  banReason    String?
  banExpires   DateTime?
  role         String       @default("user")

  // Better Auth Relations
  sessions      Session[]
  accounts      Account[]      

  // --- SAAS & BILLING ---
  
  plan          PlanType    @default(FREE)
  planStatus    PlanStatus  @default(ACTIVE)

  // 1. MONEDA REAL (IA): Créditos acumulables/mensuales
  monthlyCredits  Int   @default(0) 
  extraCredits    Int   @default(0) 
  lifetimeCredits Int   @default(0)

  // 2. LÍMITE DIARIO (Scraping): Se resetea cada 24h
  usage           UserUsage?

  // Subscription Details
  subscriptionProvider   SubscriptionProvider?
  subscriptionId         String?   @unique
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  cancelAtPeriodEnd      Boolean   @default(false)

  lemonSqueezyCustomerId String?   @unique
  lemonSqueezyVariantId  String?

  // Relations
  creditHistory CreditTransaction[]
  purchases     Purchase[]
  trackedApps   TrackedApp[]
  analyses      Analysis[]
  chatMessages  ChatMessage[]
  favorites     Favorite[]
  userGamification UserGamification?
  userAchievements UserAchievement[]
  quests UserQuest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([plan])
  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  impersonatedBy String?
  
  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

// ============================================
// GAMIFICATION
// ============================================
model UserGamification {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  xp        Int      @default(0)
  level     Int      @default(1)
  
  totalAnalyses     Int @default(0)
  highestScoreFound Int @default(0)

  streakDays      Int @default(0)
  lastStreakUpdate DateTime @default(now())

  stats Json? @default("{}")

  updatedAt DateTime @updatedAt
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  achievementId String   // ej: "gold_miner"
  unlockedAt    DateTime @default(now())

  @@unique([userId, achievementId]) // No puedes ganar el mismo logro 2 veces
}

model UserQuest {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Identificadores
  questId     String   // ID de la plantilla (ej: "category_explorer")
  type        String   // "DAILY" o "WEEKLY"
  
  // --- CAMPOS NECESARIOS QUE TE FALTAN ---
  title       String   // ej: "Finance Specialist"
  description String   
  criteria    Json     // ej: { "genre": "FINANCE", "action": "ANALYSIS" }
  status      QuestStatus @default(ACTIVE) 
  // ---------------------------------------

  // Progreso
  progress    Int      @default(0)
  target      Int      
  xpReward    Int      
  
  expiresAt   DateTime 
  createdAt   DateTime @default(now())

  @@index([userId, status])
}
// ============================================
// TRACKING DE USO
// ============================================

model UserUsage {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // --- TRACKING DIARIO (Scraping) ---
  dayDate       String   @default("") // Formato "YYYY-MM-DD"
  dailySearches Int      @default(0)

  // --- TRACKING MENSUAL (Chatbot) ---
  // Usamos el periodo de facturación para saber cuándo resetear
  billingCycleStr String   @default("") // Formato "YYYY-MM"
  monthlyChatCount Int     @default(0)
  
  updatedAt DateTime @updatedAt
}

// ============================================
// SISTEMA DE CRÉDITOS (IA)
// ============================================

model CreditTransaction {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    CreditTransactionType
  amount  Int     // Puede ser negativo (gasto) o positivo (compra)
  balance Int     // Saldo después de la transacción

  reason      String  // "ai_analysis", "monthly_reset"
  description String?

  // Opcional: Vincular a una compra real de dinero
  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id])

  // Metadata útil: { "appId": "com.whatsapp", "tokensUsed": 450 }
  metadata Json?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

// ============================================
// COMPRAS (LemonSqueezy)
// ============================================

model Purchase {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type     PurchaseType
  provider SubscriptionProvider

  // Qué compró
  plan    PlanType?
  credits Int?      // Si compró un pack de créditos extra

  amount   Int      // En centavos
  currency String   @default("usd")

  // IDs externos
  providerPaymentId      String   @unique // ID de LemonSqueezy Order / Subscription
  providerProductId      String?
  providerCustomerId     String?
  providerSubscriptionId String?

  metadata Json? // Metadata adicional (ej: packId, appId, etc.)

  status PurchaseStatus

  creditTransactions CreditTransaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

// ============================================
// CORE APP: SCRAPING & ANALYSIS
// ============================================

model TrackedApp {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  appId    String   // com.example.app
  platform Platform @default(ANDROID)

  name      String?
  iconUrl   String?
  developer String?

  // Historial de análisis de esta app para este usuario
  analyses Analysis[] @relation("AppAnalyses")

  lastAnalysisId String? @unique
  lastAnalysis   Analysis? @relation("LastAppAnalysis", fields: [lastAnalysisId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, appId]) // Un usuario solo trackea una app una vez
}

model Analysis {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relación con la app trackeada
  trackedAppId String?
  trackedApp   TrackedApp? @relation("AppAnalyses", fields: [trackedAppId], references: [id])

  // Relación inversa para saber si fue el último
  lastAnalysisOf TrackedApp? @relation("LastAppAnalysis")

  // Datos crudos del momento (Snapshot)
  appId       String
  appName     String? 
  appIcon     String?
  platform    Platform @default(ANDROID)
  
  // Scraping Result
  rawReviews  Json     // Array de reviews scrapeadas
  reviewCount Int

  // AI Result
  insights    Json     // El análisis de oportunidades de negocio
  sentiment   Json?    // Resumen de sentimiento
  opportunityScore Int @default(0)
  
  // Costo
  creditsUsed Int      @default(1)

  // Features detectadas
  featureRequests FeatureRequest[]

  // Chat context
  chatMessages ChatMessage[]

  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([appId])
}

model FeatureRequest {
  id         String   @id @default(cuid())
  analysisId String
  analysis   Analysis @relation(fields: [analysisId], references: [id], onDelete: Cascade)

  title       String
  description String?
  sentiment   String? // "negative" (queja) o "suggestion"
  frequency   Int     // Cuántas personas mencionaron esto
  priority    FeaturePriority @default(MEDIUM)

  createdAt DateTime @default(now())
}

// ============================================
// CHATBOT CONTEXT
// ============================================

model ChatMessage {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // El chat siempre es sobre un análisis específico
  analysisId String
  analysis   Analysis @relation(fields: [analysisId], references: [id], onDelete: Cascade)

  role       ChatRole // USER, ASSISTANT
  content    String   @db.Text

  // Costo (opcional, si cobras por mensaje)
  creditsUsed Int     @default(0)

  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([analysisId])
}

// ============================================
// FAVORITES
// ============================================

model Favorite {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  appId    String   // com.example.app
  appName  String?  // Nombre de la app para mostrar
  appIcon  String?  // URL del icono
  platform Platform @default(ANDROID)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, appId]) // Un usuario solo puede tener una app una vez en favoritos
  @@index([userId])
  @@index([appId])
  @@map("favorite")
}

// ============================================
// WAITLIST (Opcional, si aún la usas)
// ============================================

model WaitlistUser {
  id           String         @id @default(cuid())
  email        String         @unique
  name         String?
  referralCode String         @unique
  referredById String?
  referredBy   WaitlistUser?  @relation("Referrals", fields: [referredById], references: [id])
  referrals    WaitlistUser[] @relation("Referrals")
  invited      Boolean        @default(false)
  createdAt    DateTime       @default(now())
}

// ============================================
// PLAN LIMITS (Admin Configurable)
// ============================================

model PlanLimit {
  id             String        @id @default(cuid())
  plan           PlanType
  interval       PlanInterval
  monthlyCredits Int           @default(0) // AI análisis por mes
  dailySearches  Int           @default(0) // Búsquedas diarias permitidas
  features       Json?         // Array of PlanFeature

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([plan, interval], name: "plan_interval")
  @@index([plan])
  @@map("plan_limit")
}